#set( $ctx.stash.transactGetItems = [] ) 

## Fetch the "old" annotation, so that we can diff the tags and cascade
## updates to tables correctly.
##
## Old annotation is also used as a basis for the returned annotation
## value.
#set( $getAnnotationOperation = {
  "table": $ctx.stash.constants.ANNOTATION_TABLE,
  "key": {
    "creatorUsername": $util.dynamodb.toDynamoDB($ctx.stash.creatorUsername), 
    "id": $util.dynamodb.toDynamoDB($ctx.stash.input.id)
  }
} )
$util.qr($ctx.stash.transactGetItems.add($getAnnotationOperation))


## If annotation body has not added new tags, fetch information required
## to perform potential cascaded update to associated Annotation Colletions
## in response to tags being added or removed.
#if( !$util.isNull($ctx.stash.newBody) && $ctx.stash.newBody.size() > 0 )

  ## For each tag associated with the update annotation, try to fetch the 
  ## associated Annotation Collection to determine if the tag is new w.r.t
  ## the creator. This overfetches, as not all tags are new w.r.t the
  ## annotation. 
  #foreach( $body in $util.defaultIfNull($ctx.stash.newBody, []) )
    #set( $isTextualBody = $body.type == "TEXTUAL_BODY" )
    #set( $hasId = !$util.isNull($body.id) )
    #set( $hasTag = false )
    #foreach( $motivation in $util.defaultIfNull($body.purpose, []) )
      #if( $motivation == "TAGGING" )
        #set( $hasTag = true )
      #end
    #end

    #if( $isTextualBody && $hasId && $hasTag )
      #set( $operation = {
        "table": $ctx.stash.constants.ANNOTATION_COLLECTION_TABLE,
        "key": {
          "creatorUsername": $util.dynamodb.toDynamoDB($ctx.stash.creatorUsername),
          "id": $util.dynamodb.toDynamoDB($body.id)
        }
      } )

      $util.qr($ctx.stash.transactGetItems.add($operation))
    #end
  #end
#end

{
  "version": "2018-05-29",
  "operation": "TransactGetItems",
  "transactItems": $util.toJson($ctx.stash.transactGetItems)
}
