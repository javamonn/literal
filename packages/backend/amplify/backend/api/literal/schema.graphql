enum TextDirection {
  TR
  RTL
  AUTO
}

# https://www.iana.org/assignments/media-types/media-types.xhtml
enum Format {
  TEXT_PLAIN
}

enum ResourceType {
  DATASET
  IMAGE
  VIDEO
  SOUND
  TEXT
}

enum TextualBodyType {
  TEXTUAL_BODY
}

enum SpecificResourceType {
  SPECIFIC_RESOURCE
}

enum FragmentSelectorType {
  FRAGMENT_SELECTOR
}

enum CssSelectorType {
  CSS_SELECTOR
}

enum XPathSelectorType {
  XPATH_SELECTOR
}

enum TextQuoteSelectorType {
  TEXT_QUOTE_SELECTOR
}

enum Language {
  EN_US
}

enum ChoiceType {
  CHOICE
}

enum Motivation {
  ACCESSING
  BOOKMARKING
  CLASSIFYING
  COMMENTING
  DESCRIBING
  EDITING
  HIGHLIGHTING
  IDENTIFYING
  LINKING
  MODERATING
  QUESTIONING
  REPLYING
  TAGGING
}

interface Resource {
  format: Format
  language: Language
  processingLanguage: Language
  textDirection: TextDirection
  #https://schema.org/accessibilityFeature
  accessibility: [String!]
  rights: [AWSURL!]
}

type Target implements Resource {
  id: AWSURL!
  format: Format
  language: Language
  processingLanguage: Language
  textDirection: TextDirection
  type: ResourceType
  accessibility: [String!]
  rights: [AWSURL!]
}

type TextualBody implements Resource {
  id: AWSURL
  value: String!
  format: Format
  language: Language
  processingLanguage: Language
  textDirection: TextDirection
  type: TextualBodyType
  accessibility: [String!]
  purpose: [Motivation!]
  rights: [AWSURL!]
}

type ExternalBody implements Resource {
  id: AWSURL!
  format: Format
  language: Language
  processingLanguage: Language
  textDirection: TextDirection
  type: ResourceType
  accessibility: [String!]
  rights: [AWSURL!]
}

type ChoiceBody {
  type: ChoiceType
  items: [AnnotationBody!]!
}

type FragmentSelector {
  type: FragmentSelectorType!
  value: String!
  conformsTo: AWSURL
  refinedBy: [Selector!]
}

type CssSelector {
  type: CssSelectorType!
  value: String!
  refinedBy: [Selector!]
}

type XPathSelector {
  type: XPathSelectorType!
  value: String!
  refinedBy: [Selector!]
}

type TextQuoteSelector {
  type: TextQuoteSelectorType!
  exact: String!
  prefix: String
  suffix: String
  refinedBy: [Selector!]
}

enum TextPositionSelectorType {
  TEXT_POSITION_SELECTOR
}
type TextPositionSelector {
  type: TextPositionSelectorType!
  start: Int!
  end: Int!
  refinedBy: [Selector!]
}

enum DataPositionSelectorType {
  DATA_POSITION_SELECTOR
}
type DataPositionSelector {
  type: DataPositionSelectorType!
  start: Int!
  end: Int!
  refinedBy: [Selector!]
}

enum SvgSelectorType {
  SVG_SELECTOR
}
type SvgSelector {
  type: SvgSelectorType!
  value: String!
  refinedBy: [Selector!]
}

enum RangeSelector {
  RANGE_SELECTOR 
}
type RangeSelector {
  type: RangeSelectorType!
  startSelector: Selector!
  endSelector: Selector!
  refinedBy: [Selector!]
}

union Selector =
    FragmentSelector
  | CssSelector
  | XPathSelector
  | TextQuoteSelector
  | TextPositionSelector
  | DataPositionSelector
  | SvgSelector
  | RangeSelector

type SpecificBody {
  id: AWSURL
  type: SpecificResourceType
  purpose: [Motivation!]
  source: AnnotationBody!
  selector: [Selector!]
}

union AnnotationBody = ExternalBody | TextualBody | ChoiceBody | SpecificBody

enum AgentType {
  PERSON
  ORGANIZATION
  SOFTWARE
}

type Agent @model {
  id: AWSURL!
  type: AgentType!
  name: String
  nickname: String
  email_sha1: [String]
  email: [String]
  homepage: [String]
}

# https://schema.org/Audience
#
# TODO: should probably be a union type of all possible Audience types in order to handle metadata
type Audience {
  id: AWSURL
  type: [String!]
}

enum AnnotationType {
  ANNOTATION
}

type Annotation @model {
  context: [String!]!
  type: [AnnotationType!]!
  id: AWSURL!
  body: [AnnotationBody!]
  target: [Target!]!
  creator: Agent @connection
  created: AWSDateTime
  generator: Agent @connection
  generated: AWSDateTime
  modified: AWSDateTime
  audience: [Audience!]
  motivation: [Motivation!]
  via: [AWSURL!]
  canonical: AWSURL
}
