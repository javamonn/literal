enum TextDirection {
  TR
  RTL
  AUTO
}

# https://www.iana.org/assignments/media-types/media-types.xhtml
enum Format {
  TEXT_PLAIN
}

enum ResourceType {
  DATASET
  IMAGE
  VIDEO
  SOUND
  TEXT
}

enum TextualBodyType {
  TEXTUAL_BODY
}

enum SpecificResourceType {
  SPECIFIC_RESOURCE
}

enum FragmentSelectorType {
  FRAGMENT_SELECTOR
}

enum CssSelectorType {
  CSS_SELECTOR
}

enum XPathSelectorType {
  XPATH_SELECTOR
}

enum TextQuoteSelectorType {
  TEXT_QUOTE_SELECTOR
}

enum Language {
  EN_US
}

enum ChoiceType {
  CHOICE
}

enum Motivation {
  ACCESSING
  BOOKMARKING
  CLASSIFYING
  COMMENTING
  DESCRIBING
  EDITING
  HIGHLIGHTING
  IDENTIFYING
  LINKING
  MODERATING
  QUESTIONING
  REPLYING
  TAGGING
}

interface Resource {
  format: Format
  language: Language
  processingLanguage: Language
  textDirection: TextDirection
  #https://schema.org/accessibilityFeature
  accessibility: [String!]
  rights: [AWSURL!]
}

type Target implements Resource {
  id: AWSURL!
  format: Format
  language: Language
  processingLanguage: Language
  textDirection: TextDirection
  type: ResourceType
  accessibility: [String!]
  rights: [AWSURL!]
}

type TextualBody implements Resource {
  id: AWSURL
  value: String!
  format: Format
  language: Language
  processingLanguage: Language
  textDirection: TextDirection
  type: TextualBodyType
  accessibility: [String!]
  purpose: [Motivation!]
  rights: [AWSURL!]
}

type ExternalBody implements Resource {
  id: AWSURL!
  format: Format
  language: Language
  processingLanguage: Language
  textDirection: TextDirection
  type: ResourceType
  accessibility: [String!]
  rights: [AWSURL!]
}

type ChoiceBody {
  type: ChoiceType
  items: [AnnotationBody!]!
}

type FragmentSelector {
  type: FragmentSelectorType!
  value: String!
  conformsTo: AWSURL
  refinedBy: [Selector!]
}

type CssSelector {
  type: CssSelectorType!
  value: String!
  refinedBy: [Selector!]
}

type XPathSelector {
  type: XPathSelectorType!
  value: String!
  refinedBy: [Selector!]
}

type TextQuoteSelector {
  type: TextQuoteSelectorType!
  exact: String!
  prefix: String
  suffix: String
  refinedBy: [Selector!]
}

enum TextPositionSelectorType {
  TEXT_POSITION_SELECTOR
}
type TextPositionSelector {
  type: TextPositionSelectorType!
  start: Int!
  end: Int!
  refinedBy: [Selector!]
}

enum DataPositionSelectorType {
  DATA_POSITION_SELECTOR
}
type DataPositionSelector {
  type: DataPositionSelectorType!
  start: Int!
  end: Int!
  refinedBy: [Selector!]
}

enum SvgSelectorType {
  SVG_SELECTOR
}
type SvgSelector {
  type: SvgSelectorType!
  value: String!
  refinedBy: [Selector!]
}

enum RangeSelectorType {
  RANGE_SELECTOR
}
type RangeSelector {
  type: RangeSelectorType!
  startSelector: Selector!
  endSelector: Selector!
  refinedBy: [Selector!]
}

union Selector =
    FragmentSelector
  | CssSelector
  | XPathSelector
  | TextQuoteSelector
  | TextPositionSelector
  | DataPositionSelector
  | SvgSelector
  | RangeSelector

enum TimeStateType {
  TIME_STATE
}
type TimeState {
  type: TimeStateType!
  sourceDate: [AWSDateTime!]
  sourceDateStart: AWSDateTime
  sourceDateEnd: AWSDateTime
  cached: [AWSURL!]
  refinedBy: [StateOrSelector!]
}

enum HttpRequestStateType {
  HTTP_REQUEST_STATE
}

type HttpRequestState {
  type: HttpRequestStateType!
  value: String!
  refinedBy: [StateOrSelector!]
}

type RenderedVia {
  id: AWSURL!
}

union State = TimeState | HttpRequestState
union StateOrSelector =
    TimeState
  | HttpRequestState
  | FragmentSelector
  | CssSelector
  | XPathSelector
  | TextQuoteSelector
  | TextPositionSelector
  | DataPositionSelector
  | SvgSelector
  | RangeSelector

type SpecificBody {
  id: AWSURL
  type: SpecificResourceType
  purpose: [Motivation!]
  source: AnnotationBody!
  selector: [Selector!]
  state: [State!]
  styleClass: [String!]
  renderedVia: [RenderedVia!]
  scope: [AWSURL!]
}

union AnnotationBody = ExternalBody | TextualBody | ChoiceBody | SpecificBody

enum CssStylesheetType {
  CSS_STYLESHEET
}

type CssStylesheet {
  type: CssStylesheetType!
  value: String!
}

enum AgentType {
  PERSON
  ORGANIZATION
  SOFTWARE
}

type Agent
  @model
  @auth(
    rules: [
      { allow: owner, ownerField: "id", operations: [read, update] }
      {
        allow: private
        provider: iam
        operations: [create, read, update, delete]
      }
    ]
  )
  @key(fields: ["id"]) {
  id: AWSURL!
  type: AgentType!
  name: String
  nickname: String
  email_sha1: [String]
  email: [String]
  homepage: [String]
}

# https://schema.org/Audience
#
# TODO: should probably be a union type of all possible Audience types in order to handle metadata
type Audience {
  id: AWSURL
  type: [String!]
}

enum AnnotationType {
  ANNOTATION
}

type Annotation
  @model(
    queries: { get: "getAnnotation", list: "listAnnotations" }
    mutations: null
    subscriptions: null
    timestamps: { createdAt: "created", updatedAt: "modified" }
  )
  @auth(
    rules: [
      {
        allow: owner
        ownerField: "creator"
        operations: [create, read, update, delete]
      }
    ]
  )
  @key(fields: ["creatorId", "id"]) {
  context: [String!]!
  type: [AnnotationType!]!
  id: AWSURL!
  body: [AnnotationBody!]
  target: [Target!]!
  creatorId: AWSURL!
  creator: Agent! @connection(fields: ["creatorId"])
  created: AWSDateTime
  generator: Agent @connection
  generated: AWSDateTime
  modified: AWSDateTime
  audience: [Audience!]
  motivation: [Motivation!]
  via: [AWSURL!]
  canonical: AWSURL
  stylesheet: CssStylesheet
}

enum AnnotationCollectionType {
  ANNOTATION_COLLECTION
}
type AnnotationCollection
  @model(
    queries: {
      get: "getAnnotationCollection"
      list: "listAnnotationCollections"
    }
    mutations: null
    subscriptions: null
    timestamps: { createdAt: "created", updatedAt: "modified" }
  )
  @auth(
    rules: [
      {
        allow: owner
        ownerField: "creatorId"
        operations: [create, read, update, delete]
      }
    ]
  )
  @key(fields: ["creatorId", "id"]) {
  context: [String!]!
  id: AWSURL!
  type: [AnnotationCollectionType!]!
  label: [String!]
  total: Int
  first: AnnotationPage @connection
  last: AnnotationPage @connection
  creator: Agent! @connection(fields: ["creatorId"])
  creatorId: AWSURL!
  created: AWSDateTime
}

type AnnotationPageItem
  @model(
    queries: { get: "getAnnotationPageItem", list: "listAnnotationPageItems" }
    mutations: null
    subscriptions: null
    timestamps: { createdAt: "created", updatedAt: "modified" }
  )
  @key(fields: ["creatorId", "id"])
  @key(name: "byAnnotationPage", fields: ["annotationPageId", "annotationId"])
  @key(name: "byAnnotation", fields: ["annotationId", "annotationPageId"])
  @auth(
    rules: [
      {
        allow: owner
        ownerField: "creatorId"
        operations: [create, read, update, delete]
      }
    ]
  ) {
  id: ID!
  annotationPageId: AWSURL!
  annotationId: AWSURL!
  annotation: Annotation! @connection(fields: ["annotationId"])
  annotationPage: AnnotationPage! @connection(fields: ["annotationPageId"])
  creatorId: AWSURL!
  creator: Agent! @connection(fields: ["creatorId"])
  created: AWSDateTime
  modified: AWSDateTime
}

enum AnnotationPageType {
  ANNOTATION_PAGE
}
type AnnotationPage
  @model(
    queries: { get: "getAnnotationPage", list: "listAnnotationPages" }
    mutations: null
    subscriptions: null
    timestamps: { createdAt: "created", updatedAt: "modified" }
  )
  @auth(
    rules: [
      {
        allow: owner
        ownerField: "creatorId"
        operations: [create, read, update, delete]
      }
    ]
  )
  @key(fields: ["creatorId", "id"]) {
  context: [String!]!
  id: AWSURL!
  type: [AnnotationPageType!]!
  partOf: AnnotationCollection @connection
  items: [AnnotationPageItem!]!
    @connection(keyName: "byAnnotationPage", fields: ["id"])
  next: AnnotationPage @connection
  prev: AnnotationPage @connection
  startIndex: Int
  creator: Agent! @connection(fields: ["creatorId"])
  creatorId: AWSURL!
  created: AWSDateTime
  modified: AWSDateTime
}

input CreateAnnotationInput {
  context: [String!]!
  type: [AnnotationType!]!
  id: AWSURL!
  body: [AnnotationBody!]
  target: [Target!]!
  creatorId: AWSURL!
  created: AWSDateTime
  generated: AWSDateTime
  modified: AWSDateTime
  audience: [Audience!]
  motivation: [Motivation!]
  via: [AWSURL!]
  canonical: AWSURL
  stylesheet: CssStylesheet
  creatorId: AWSURL 
  generator: AWSURL 
}

type CreateAnnotationOuput {
  annotation: Annotation!
  annotationCollections: [AnnotationCollection!]!
  annotationPageItems: [AnnotationPageItem!]!
  annotationPage: [AnnotationPage!]!
}

type Mutation {
  createAnnotation(input: CreateAnnotationInput!): CreateAnnotationOutput
}
